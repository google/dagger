/*
 * Copyright (C) 2019 The Dagger Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package dagger.hilt.processor.internal.aggregateddeps;

import static com.google.common.base.Preconditions.checkState;
import static dagger.hilt.processor.internal.Processors.toTypeElements;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.squareup.javapoet.ClassName;
import dagger.hilt.processor.internal.ComponentDescriptor;
import dagger.hilt.processor.internal.ProcessorErrors;
import dagger.hilt.processor.internal.definecomponent.DefineComponents;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.PackageElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Elements;

/**
 * Represents information needed to create a component (i.e. modules, entry points, etc)
 */
public final class ComponentDependencies {
  static final String AGGREGATING_PACKAGE = "hilt_aggregated_deps";

  private final ImmutableSetMultimap<ClassName, TypeElement> modules;
  private final ImmutableSetMultimap<ClassName, TypeElement> entryPoints;
  private final ImmutableSetMultimap<ClassName, TypeElement> componentEntryPoints;

  public ComponentDependencies(
      ImmutableSetMultimap<ClassName, TypeElement> modules,
      ImmutableSetMultimap<ClassName, TypeElement> entryPoints,
      ImmutableSetMultimap<ClassName, TypeElement> componentEntryPoints) {
    this.modules = modules;
    this.entryPoints = entryPoints;
    this.componentEntryPoints = componentEntryPoints;
  }

  /** Returns the modules for a component, without any filtering. */
  public ImmutableSet<TypeElement> getModules(ClassName componentName) {
    return modules.get(componentName);
  }

  /** Returns the entry points associated with the given a component. */
  public ImmutableSet<TypeElement> getEntryPoints(ClassName componentName) {
    return entryPoints.get(componentName);
  }

  /** Returns the component entry point associated with the given a component. */
  public ImmutableSet<TypeElement> getComponentEntryPoints(ClassName componentName) {
    return componentEntryPoints.get(componentName);
  }

  /**
   * Pulls the component dependencies from the {@code packageName}.
   *
   * <p>Dependency files are generated by the {@link AggregatedDepsProcessor}, and have the form:
   *
   * <pre>{@code
   * {@literal @}AggregatedDeps(
   *   components = {
   *       "foo.FooComponent",
   *       "bar.BarComponent"
   *   },
   *   modules = "baz.BazModule"
   * )
   *
   * }</pre>
   */
  public static ComponentDependencies from(Elements elements) {
    ImmutableSetMultimap.Builder<ClassName, TypeElement> modules = ImmutableSetMultimap.builder();
    ImmutableSetMultimap.Builder<ClassName, TypeElement> entryPoints =
        ImmutableSetMultimap.builder();
    ImmutableSetMultimap.Builder<ClassName, TypeElement> componentEntryPoints =
        ImmutableSetMultimap.builder();
    Map<String, ComponentDescriptor> descriptorLookup = new HashMap<>();
    DefineComponents.componentDescriptors(elements)
        .forEach(descriptor -> descriptorLookup.put(descriptor.component().toString(), descriptor));

    for (AggregatedDeps deps : getAggregatedDeps(elements)) {
      for (String component : deps.components()) {
        checkState(
            descriptorLookup.containsKey(component),
            "%s is not a valid Component. Did you add or remove code in package %s?",
            component,
            AGGREGATING_PACKAGE,
            component);

        ComponentDescriptor desc = descriptorLookup.get(component);
        modules.putAll(desc.component(), toTypeElements(elements, deps.modules()));
        entryPoints.putAll(desc.component(), toTypeElements(elements, deps.entryPoints()));
        componentEntryPoints.putAll(
            desc.component(), toTypeElements(elements, deps.componentEntryPoints()));
      }
    }

    return new ComponentDependencies(
        modules.build(), entryPoints.build(), componentEntryPoints.build());
  }

  /** Returns the top-level elements of the aggregated deps package. */
  private static ImmutableList<AggregatedDeps> getAggregatedDeps(Elements elements) {
    PackageElement packageElement = elements.getPackageElement(AGGREGATING_PACKAGE);
    checkState(
        packageElement != null,
        "Couldn't find package %s. Did you mark your @Module classes with @InstallIn annotations?",
        AGGREGATING_PACKAGE);

    List<? extends Element> aggregatedDepsElements = packageElement.getEnclosedElements();
    checkState(
        !aggregatedDepsElements.isEmpty(),
        "No dependencies found. Did you mark your @Module classes with @InstallIn annotations?");

    ImmutableList.Builder<AggregatedDeps> builder = ImmutableList.builder();
    for (Element element : aggregatedDepsElements) {
      ProcessorErrors.checkState(
          element.getKind() == ElementKind.CLASS,
          element,
          "Only classes may be in package %s. Did you add custom code in the package?",
          AGGREGATING_PACKAGE);

      AggregatedDeps aggregatedDeps = element.getAnnotation(AggregatedDeps.class);
      ProcessorErrors.checkState(
          aggregatedDeps != null,
          element,
          "Classes in package %s must be annotated with @AggregatedDeps: %s. Found: %s.",
          AGGREGATING_PACKAGE,
          element.getSimpleName(),
          element.getAnnotationMirrors());

      builder.add(aggregatedDeps);
    }
    return builder.build();
  }
}
